{"version":3,"sources":["components/AddCategory.js","helpers/GetGif.js","components/GifGreedItem.js","components/GifGreed.js","Hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setcategories","useState","InputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","console","log","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGreedItem","className","src","alt","GifGreed","loading","state","setstate","useEffect","then","imgs","setTimeout","useFetchGifs","key","GifExpertApp","categories","i","ReactDOM","render","document","getElementById"],"mappings":"oMAEaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EAGZC,mBAAS,IAHG,mBAGzCC,EAHyC,KAG7BC,EAH6B,KAsBhD,OACE,sBAAMC,SAZa,SAACC,GACpBA,EAAEC,iBAIEJ,EAAWK,OAAOC,OAAS,IAC7BR,GAAc,SAACS,GAAD,OAAWP,GAAX,mBAA0BO,OAExCN,EAAc,MAIhB,SAEE,uBACEO,KAAK,OACLC,MAAOT,EACPU,SAvBoB,SAACP,GACzBQ,QAAQC,IAAIT,EAAEU,OAAOJ,OAGrBR,EAAcE,EAAEU,OAAOJ,a,8BCXdK,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEfC,EAFe,iDAEiCC,UACpDH,GAHmB,+DAKFI,MAAMF,GALJ,cAKfG,EALe,gBAMEA,EAAKC,OANP,uBAMbC,EANa,EAMbA,KAIFC,EAAOD,EAAKE,KAAI,SAACC,GAAS,IAAD,EAC7B,MAAO,CACLC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAdjB,kBAkBdM,GAlBc,4CAAH,sDCEPO,EAAe,SAAC,GAAwB,IAAtBJ,EAAqB,EAArBA,GAAIC,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAExC,OADAN,QAAQC,IAAI,CAAEc,KAAIC,QAAOV,QAEvB,sBAAKc,UAAU,2BAAf,UACE,4BAAIJ,IACJ,qBAAKK,IAAKf,EAAKgB,IAAKN,QCAbO,EAAW,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECDd,SAACA,GAAc,IAAD,EACdhB,mBAAS,CAGjCuB,KAAM,GACNa,SAAS,IAL6B,mBACjCC,EADiC,KAC1BC,EAD0B,KAwBxC,OAfAC,qBAAU,WAGRxB,EAAQC,GAAUwB,MAAK,SAACC,GAGtBC,YAAW,WACTJ,EAAS,CACPf,KAAMkB,EACNL,SAAS,MAEV,UAEJ,CAACpB,IAEGqB,EDpB2BM,CAAa3B,GAAjCa,EAH0B,EAGhCN,KAAca,EAHkB,EAGlBA,QAmBtB,OACE,qCACE,6BAAKpB,IACL,sBAAKgB,UAAU,gCAAf,UAGGI,GAAW,mBAAGJ,UAAU,sBAAb,wBAMXH,EAAOJ,KAAI,SAACC,GAAD,OAEV,uBADA,CACC,EAAD,2BAAkBA,GAAlB,IAAuBkB,IAAKlB,EAAIC,gBEQ3BkB,EA/CM,WAAM,MAEW7C,mBAAS,CAAC,eAFrB,mBAElB8C,EAFkB,KAEN/C,EAFM,KAiBzB,OACE,qCACE,8CAEA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBAEA,6BAYI+C,EAAWrB,KAAI,SAACT,EAAU+B,GAAX,OAGb,aAFA,CAEC,EAAD,CAAyB/B,SAAUA,GAApBA,Y,MCtC3BgC,IAASC,OAAO,cAAC,EAAD,IAAkBC,SAASC,eAAe,W","file":"static/js/main.54a1e03d.chunk.js","sourcesContent":["import React, { useState } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nexport const AddCategory = ({ setcategories }) => {\r\n  //dejamos el estado inicial en \"\" para que no se quede como undefined\r\n  //si no colocamos nada en el estado inicial nos genera error\r\n  const [InputValue, setInputValue] = useState(\"\");\r\n  //esta funcion se va a ejecutar cada ves que el input cambie\r\n  const handleInputChange = (e) => {\r\n    console.log(e.target.value);\r\n    //el valor que se obtiene cada ves que se escriba en el input y ira agregando al InputValue\r\n    //de esta forma tendremos el InputValue actualizado cada ves que se escriba en el input\r\n    setInputValue(e.target.value);\r\n  };\r\n  const handleSubmit = (e) => {\r\n    e.preventDefault();\r\n    // console.log(\"Submit Hecho\");\r\n    //.trim => elimina los espacios en blanco\r\n    //si los espacios en blanco eliminados son mayores a 2 entonces va a agregar al arreglo\r\n    if (InputValue.trim().length > 2) {\r\n      setcategories((cats) => [InputValue, ...cats]);\r\n      //una ves insertado, borramos el valor para que no se haga un doble posteo\r\n      setInputValue(\"\");\r\n    }\r\n  };\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      {/* el onChange se dispara cada vez que el input cambie */}\r\n      <input\r\n        type=\"text\"\r\n        value={InputValue}\r\n        onChange={handleInputChange}\r\n      ></input>\r\n    </form>\r\n  );\r\n};\r\nAddCategory.propTypes = {\r\n  setcategories: PropTypes.func.isRequired,\r\n};\r\n","export const getGifs = async (category) => {\r\n  //encodeURI => quita los espacios en blanco\r\n  const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(\r\n    category\r\n  )}&limit=10&api_key=h4JOGyy03lks6KjzxrIKyixeVdiTUA0S`;\r\n  const resp = await fetch(url);\r\n  const { data } = await resp.json();\r\n  //vamos a crear un nuevo objeto utiliozando map con la informacion del api\r\n  //en este caso solo queremos el id, title y la url\r\n  //con esta informacion generamos un nuevo objeto\r\n  const gifs = data.map((img) => {\r\n    return {\r\n      id: img.id,\r\n      title: img.title,\r\n      url: img.images?.downsized_medium.url,\r\n    };\r\n  });\r\n  //retorna una promesa que resuelve la coleccion de las imagenes\r\n  return gifs;\r\n};\r\n","import React from \"react\";\r\n\r\nexport const GifGreedItem = ({ id, title, url }) => {\r\n  console.log({ id, title, url });\r\n  return (\r\n    <div className=\"card animate__backInDown\">\r\n      <p>{title}</p>\r\n      <img src={url} alt={title}></img>\r\n    </div>\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport { useFetchGifs } from \"../Hooks/useFetchGifs\";\r\n// import { getGifs } from \"../helpers/GetGif\";\r\nimport { GifGreedItem } from \"./GifGreedItem\";\r\n//customHooks => es extraer logica de un componente para reutilizar de tal manera\r\n//que sea sencillo utilizarlo nuevamente\r\n//useEfeect => permite ejecutar cierto codigo de manera condicional\r\nexport const GifGreed = ({ category }) => {\r\n  // const [Images, setImages] = useState([]);\r\n  //si queremos renombrar una propiedad de un objeto colocamos :nombrenuevo\r\n  const { data: images, loading } = useFetchGifs(category);\r\n  // //necesitamos obtener la categoria y realizar una peticion http\r\n  // //useEfeect => permite ejecutar cierto codigo de manera condicional\r\n  // //el primer parametro que recibe es la funcion que queremos que ejecute\r\n  // useEffect(() => {\r\n  //   //llamamos a la funcion y esta retorna una promesa\r\n  //   //para lo cual usamos un then y obtenemos las imagenes y estas imagenes la pasamos al setImages\r\n  //   getGifs(category).then((imgs) => {\r\n  //     setImages(imgs);\r\n  //   });\r\n  //   //el segundo parametro es un arreglo de dependecias\r\n  //   //este arreglo vacio significa que la funcion que esta dentro del useEffects se ejecutara\r\n  //   //cuando el componente es renderizado por primera vez,\r\n  //   //si este useEffect la funcion getGifs se ejecutara cada vez que se renderiza todo el componente\r\n  //   //\r\n  //   //si la categoria cambia entonces volvera a ejecutar este userEffect\r\n  // }, [category]);\r\n\r\n  //   getGifs();\r\n  return (\r\n    <>\r\n      <h3>{category}</h3>\r\n      <div className=\"card-grid animate__backInDown\">\r\n        {/* si loading es true entonces mostrara Loading pero si es false\r\n        entonces no va a mostrar nada */}\r\n        {loading && <p className=\"animate__backInDown\">Loading...</p>}\r\n        {/* funcion flecha con llaves, necesita un return\r\n        {Images.map((image) => {\r\n            return <h3>{image.title}</h3>;\r\n        })} */}\r\n        {/* funcion flecha sin llaves y con parentesis, no necesita un return */}\r\n        {images.map((img) => (\r\n          //al usar ... => operador spreet, le mandamos de manera independiente cada propiedad\r\n          <GifGreedItem {...img} key={img.id}></GifGreedItem>\r\n        ))}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n","//todos los hook empiezan con use\r\n\r\nimport { useEffect, useState } from \"react\";\r\nimport { getGifs } from \"../helpers/GetGif\";\r\n\r\n//estos no son mas que funciones\r\nexport const useFetchGifs = (category) => {\r\n  const [state, setstate] = useState({\r\n    //cuando se utilize por primera vez el useFetchGifs\r\n    //tendremos este estado que estara cargando por defecto\r\n    data: [],\r\n    loading: true,\r\n  });\r\n  //evaluamos unicamente el efecto cuando la categoria cambia, es decir se va a disparar\r\n  //el efecto cuando inicie o se cambie la categoria\r\n  useEffect(() => {\r\n    //le vamos a mandar la informacion del nuevo estado\r\n    //hacemos la peticion al api y cargamos las imagenes\r\n    getGifs(category).then((imgs) => {\r\n      //colocamos el timeout y despues de 3 seg le pasamos las imagenes a la data\r\n      //y cambiamos el valor de loading a false\r\n      setTimeout(() => {\r\n        setstate({\r\n          data: imgs,\r\n          loading: false,\r\n        });\r\n      }, 3000);\r\n    });\r\n  }, [category]);\r\n  //y retornara este objeto\r\n  return state;\r\n};\r\n","import React, { useState } from \"react\";\r\nimport { AddCategory } from \"./components/AddCategory\";\r\nimport { GifGreed } from \"./components/GifGreed\";\r\n\r\nconst GifExpertApp = () => {\r\n  //   const categories = [\"One Punche\", \"Samurai X\", \"Dragon Ball\"];\r\n  const [categories, setcategories] = useState([\"One Punche\"]);\r\n  //   const handleAdd = () => {\r\n  //     //cuando usamos setCategories, le estamos cayendo encima al estado anterior\r\n  //     //y esta creando un nuevo estado\r\n  //     //para agregar elemento al arreglo sin cambiar el arreglo inicial\r\n  //     //podemos usar el operador spreet (...), es decir extraer las categorias\r\n  //     //y añadirles una nueva, de esta forma mantenemos las categorias anteriores\r\n  //     //y añadimos una nueva\r\n  //     // setcategories([...categories, \"HunterXHunter\"]);\r\n  //     //otra solucion seria\r\n  //     //el setcategories recibe un callback, el cual tiene\r\n  //     //como primer argumento el valor del estado anterior, y obtenemos las categorias\r\n  //     //entonces podemos regresar un nuevo arreglo con todas las categorias mas la nueva categoria\r\n  //     setcategories((cats) => [...cats, \"HunterXHunter\"]);\r\n  //   };\r\n  return (\r\n    <>\r\n      <h2>GifExpertApp</h2>\r\n      {/* le podemos pasar la funcion setCategories como una propiedad a nuestro componente*/}\r\n      <AddCategory setcategories={setcategories}></AddCategory>\r\n      <hr></hr>\r\n      {/* <button onClick={handleAdd}>Agregar</button> */}\r\n      <ol>\r\n        {\r\n          /* necesitamos una expresion que regrese algo\r\n            usamos map=> este transforma cada uno de los elementos que estan dentro de su arreglo,\r\n            es decir lo que sea que regremos en el map sera el nuevo valor para cada uno de los\r\n            elementos del arreglo ejemplo return hola => [\"hola\",\"hola\",\"hola\"]\r\n            el map recibe 2 argumentos, primero el elemento del arreglo y como segundo argumento\r\n            el indice, este indice podria servir para el key pero \r\n            es volatil, es decir puede cambiar el indice, es mejor usar\r\n            otro id unico para cada elemento, el key sirve para que react sepa cual\r\n            ese el elemento que se esta iterando y si ese elemento cambia o necesita renderizar\r\n            de vuelta, se basara en el key*/\r\n          categories.map((category, i) => (\r\n            //le pasamos la propiedad de categoria a nuestro componente de GifGreed\r\n            //de igual forma el key es la category\r\n            <GifGreed key={category} category={category}></GifGreed>\r\n          ))\r\n        }\r\n      </ol>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default GifExpertApp;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport GifExpertApp from \"./GifExpertApp\";\nimport \"./index.css\";\n\nReactDOM.render(<GifExpertApp />, document.getElementById(\"root\"));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n"],"sourceRoot":""}